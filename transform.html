

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Time Series Transforms &mdash; seglearn 1.0.6 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/gallery.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> seglearn
          

          
          </a>

          
            
            
              <div class="version">
                1.0.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Install and contribution</a></li>
</ul>
<p class="caption"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="user_guide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="change_log.html">Change Log</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorial - Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="auto_examples/index.html">General examples</a></li>
</ul>
<p class="caption"><span class="caption-text">Addtional Information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="citations.html">Citing seglearn</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">seglearn</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Time Series Transforms</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/transform.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-seglearn.transform">
<span id="time-series-transforms"></span><h1>Time Series Transforms<a class="headerlink" href="#module-seglearn.transform" title="Permalink to this headline">¶</a></h1>
<p>This module is for transforming time series data.</p>
<dl class="class">
<dt id="seglearn.transform.SegmentX">
<em class="property">class </em><code class="descclassname">seglearn.transform.</code><code class="descname">SegmentX</code><span class="sig-paren">(</span><em>width=100</em>, <em>overlap=0.5</em>, <em>shuffle=False</em>, <em>random_state=None</em>, <em>order='F'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#SegmentX"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.SegmentX" title="Permalink to this definition">¶</a></dt>
<dd><p>Transformer for sliding window segmentation for datasets where
X is time series data, optionally with contextual variables
and each time series in X has a single target value y</p>
<p>The target y is mapped to all segments from their parent series.
The transformed data consists of segment/target pairs that can be learned
through a feature representation or directly with a neural network.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>width</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd><p class="first last">width of segments (number of samples)</p>
</dd>
<dt><strong>overlap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float range [0,1]</span></dt>
<dd><p class="first last">amount of overlap between segments. must be in range: 0 &lt;= overlap &lt;= 1
(note: setting overlap to 1.0 results in the segments to being advanced by a single sample)</p>
</dd>
<dt><strong>shuffle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">shuffle the segments after transform (recommended for batch optimizations)</p>
</dd>
<dt><strong>random_state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, default = None</span></dt>
<dd><p class="first last">Randomized segment shuffling will return different results for each call to
<code class="docutils literal notranslate"><span class="pre">transform</span></code>. If you have set <code class="docutils literal notranslate"><span class="pre">shuffle</span></code> to True and want the same result
with each call to <code class="docutils literal notranslate"><span class="pre">fit</span></code>, set <code class="docutils literal notranslate"><span class="pre">random_state</span></code> to an integer.</p>
</dd>
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional (default=’F’)</span></dt>
<dd><p class="first last">Determines the index order of the segmented time series. ‘C’ means C-like index order (first
index changes slowest) and ‘F’ means Fortran-like index order (last index changes slowest).
‘C’ ordering is suggested for neural network estimators, and ‘F’ ordering is suggested for computing
feature representations.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>step</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#seglearn.transform.SegmentX.fit" title="seglearn.transform.SegmentX.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X[,&nbsp;y])</td>
<td>Fit the transform</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code>(X,&nbsp;y[,&nbsp;sample_weight])</td>
<td>Fit the data and transform (required by sklearn API)</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#seglearn.transform.SegmentX.transform" title="seglearn.transform.SegmentX.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X[,&nbsp;y,&nbsp;sample_weight])</td>
<td>Transforms the time series data into segments (temporal tensor) Note this transformation changes the number of samples in the data If y and sample_weight are provided, they are transformed to align to the new samples</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="seglearn.transform.SegmentX.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#SegmentX.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.SegmentX.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the transform</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_series, …]</span></dt>
<dd><p class="first last">Time series data and (optionally) contextual data</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd><p class="first last">There is no need of a target in a transformer, yet the pipeline API requires
this parameter.</p>
</dd>
<dt><strong>shuffle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Shuffles data after transformation</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Returns self.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="seglearn.transform.SegmentX.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>sample_weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#SegmentX.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.SegmentX.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the time series data into segments (temporal tensor)
Note this transformation changes the number of samples in the data
If y and sample_weight are provided, they are transformed to align to the new samples</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_series, …]</span></dt>
<dd><p class="first last">Time series data and (optionally) contextual data</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like shape [n_series], default = None</span></dt>
<dd><p class="first last">target vector</p>
</dd>
<dt><strong>sample_weight</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like shape [n_series], default = None</span></dt>
<dd><p class="first last">sample weights</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Xt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_segments, ]</span></dt>
<dd><p class="first last">transformed time series data</p>
</dd>
<dt><strong>yt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_segments]</span></dt>
<dd><p class="first last">expanded target vector</p>
</dd>
<dt><strong>sample_weight_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like shape [n_segments]</span></dt>
<dd><p class="first last">expanded sample weights</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="seglearn.transform.SegmentXY">
<em class="property">class </em><code class="descclassname">seglearn.transform.</code><code class="descname">SegmentXY</code><span class="sig-paren">(</span><em>width=100</em>, <em>overlap=0.5</em>, <em>y_func=&lt;function last&gt;</em>, <em>shuffle=False</em>, <em>random_state=None</em>, <em>order='F'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#SegmentXY"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.SegmentXY" title="Permalink to this definition">¶</a></dt>
<dd><p>Transformer for sliding window segmentation for datasets where
X is time series data, optionally with contextual variables
and y is also time series data with the same sampling interval as X</p>
<p>The target y is mapped to segments from their parent series,
using the parameter <code class="docutils literal notranslate"><span class="pre">y_func</span></code> to determine the mapping behavior.
The segment targets can be a single value, or a sequence of values
depending on <code class="docutils literal notranslate"><span class="pre">y_func</span></code> parameter.</p>
<p>The transformed data consists of segment/target pairs that can be learned
through a feature representation or directly with a neural network.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>width</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd><p class="first last">width of segments (number of samples)</p>
</dd>
<dt><strong>overlap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float range [0,1]</span></dt>
<dd><p class="first last">amount of overlap between segments. must be in range: 0 &lt;= overlap &lt;= 1
(note: setting overlap to 1.0 results in the segments to being advanced by a single sample)</p>
</dd>
<dt><strong>y_func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">returns target from array of target segments (eg <code class="docutils literal notranslate"><span class="pre">last</span></code>, <code class="docutils literal notranslate"><span class="pre">middle</span></code>, or <code class="docutils literal notranslate"><span class="pre">mean</span></code>)</p>
</dd>
<dt><strong>shuffle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">shuffle the segments after transform (recommended for batch optimizations)</p>
</dd>
<dt><strong>random_state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, default = None</span></dt>
<dd><p class="first last">Randomized segment shuffling will return different results for each call to <code class="docutils literal notranslate"><span class="pre">transform</span></code>.
If you have set <code class="docutils literal notranslate"><span class="pre">shuffle</span></code> to True and want the same result with each call to <code class="docutils literal notranslate"><span class="pre">fit</span></code>,
set <code class="docutils literal notranslate"><span class="pre">random_state</span></code> to an integer.</p>
</dd>
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional (default=’F’)</span></dt>
<dd><p class="first last">Determines the index order of the segmented time series. ‘C’ means C-like index order (first
index changes slowest) and ‘F’ means Fortran-like index order (last index changes slowest).
‘C’ ordering is suggested for neural network estimators, and ‘F’ ordering is suggested for computing
feature representations.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Returns self.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>step</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#seglearn.transform.SegmentXY.fit" title="seglearn.transform.SegmentXY.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X[,&nbsp;y])</td>
<td>Fit the transform</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code>(X,&nbsp;y[,&nbsp;sample_weight])</td>
<td>Fit the data and transform (required by sklearn API)</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#seglearn.transform.SegmentXY.transform" title="seglearn.transform.SegmentXY.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X[,&nbsp;y,&nbsp;sample_weight])</td>
<td>Transforms the time series data into segments Note this transformation changes the number of samples in the data If y is provided, it is segmented and transformed to align to the new samples as per <code class="docutils literal notranslate"><span class="pre">y_func</span></code> Currently sample weights always returned as None</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="seglearn.transform.SegmentXY.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#SegmentXY.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.SegmentXY.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the transform</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_series, …]</span></dt>
<dd><p class="first last">Time series data and (optionally) contextual data</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd><p class="first last">There is no need of a target in a transformer, yet the pipeline API requires this
parameter.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Returns self.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="seglearn.transform.SegmentXY.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>sample_weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#SegmentXY.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.SegmentXY.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the time series data into segments
Note this transformation changes the number of samples in the data
If y is provided, it is segmented and transformed to align to the new samples as per
<code class="docutils literal notranslate"><span class="pre">y_func</span></code>
Currently sample weights always returned as None</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_series, …]</span></dt>
<dd><p class="first last">Time series data and (optionally) contextual data</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like shape [n_series], default = None</span></dt>
<dd><p class="first last">target vector</p>
</dd>
<dt><strong>sample_weight</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like shape [n_series], default = None</span></dt>
<dd><p class="first last">sample weights</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Xt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_segments, ]</span></dt>
<dd><p class="first last">transformed time series data</p>
</dd>
<dt><strong>yt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_segments]</span></dt>
<dd><p class="first last">expanded target vector</p>
</dd>
<dt><strong>sample_weight_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="seglearn.transform.SegmentXYForecast">
<em class="property">class </em><code class="descclassname">seglearn.transform.</code><code class="descname">SegmentXYForecast</code><span class="sig-paren">(</span><em>width=100</em>, <em>overlap=0.5</em>, <em>forecast=10</em>, <em>y_func=&lt;function last&gt;</em>, <em>shuffle=False</em>, <em>random_state=None</em>, <em>order='F'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#SegmentXYForecast"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.SegmentXYForecast" title="Permalink to this definition">¶</a></dt>
<dd><p>Forecast sliding window segmentation for time series or sequence datasets</p>
<p>The target y is mapped to segments from their parent series,
using the <code class="docutils literal notranslate"><span class="pre">forecast</span></code> and <code class="docutils literal notranslate"><span class="pre">y_func</span></code> parameters to determine the mapping behavior.
The segment targets can be a single value, or a sequence of values
depending on <code class="docutils literal notranslate"><span class="pre">y_func</span></code> parameter.</p>
<p>The transformed data consists of segment/target pairs that can be learned
through a feature representation or directly with a neural network.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>width</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int &gt; 0</span></dt>
<dd><p class="first last">width of segments (number of samples)</p>
</dd>
<dt><strong>overlap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float range [0,1]</span></dt>
<dd><p class="first last">amount of overlap between segments. must be in range: 0 &lt;= overlap &lt;= 1
(note: setting overlap to 1.0 results in the segments to being advanced by a single sample)</p>
</dd>
<dt><strong>forecast</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of samples ahead in time to forecast</p>
</dd>
<dt><strong>y_func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">returns target from array of target forecast segments (eg <code class="docutils literal notranslate"><span class="pre">last</span></code>, or <code class="docutils literal notranslate"><span class="pre">mean</span></code>)</p>
</dd>
<dt><strong>shuffle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">shuffle the segments after transform (recommended for batch optimizations)</p>
</dd>
<dt><strong>random_state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, default = None</span></dt>
<dd><p class="first last">Randomized segment shuffling will return different results for each call to <code class="docutils literal notranslate"><span class="pre">transform</span></code>.
If you have set <code class="docutils literal notranslate"><span class="pre">shuffle</span></code> to True and want the same result with each call to <code class="docutils literal notranslate"><span class="pre">fit</span></code>, set
<code class="docutils literal notranslate"><span class="pre">random_state</span></code> to an integer.</p>
</dd>
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional (default=’F’)</span></dt>
<dd><p class="first last">Determines the index order of the segmented time series. ‘C’ means C-like index order (first
index changes slowest) and ‘F’ means Fortran-like index order (last index changes slowest).
‘C’ ordering is suggested for neural network estimators, and ‘F’ ordering is suggested for computing
feature representations.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Returns self.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>step</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#seglearn.transform.SegmentXYForecast.fit" title="seglearn.transform.SegmentXYForecast.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>([X,&nbsp;y])</td>
<td>Fit the transform</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code>(X,&nbsp;y[,&nbsp;sample_weight])</td>
<td>Fit the data and transform (required by sklearn API)</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#seglearn.transform.SegmentXYForecast.transform" title="seglearn.transform.SegmentXYForecast.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X,&nbsp;y[,&nbsp;sample_weight])</td>
<td>Forecast sliding window segmentation for time series or sequence datasets.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="seglearn.transform.SegmentXYForecast.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X=None</em>, <em>y=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#SegmentXYForecast.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.SegmentXYForecast.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the transform</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_series, …]</span></dt>
<dd><p class="first last">Time series data and (optionally) contextual data</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd><p class="first last">There is no need of a target in a transformer, yet the pipeline API requires this
parameter.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Returns self.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="seglearn.transform.SegmentXYForecast.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X</em>, <em>y</em>, <em>sample_weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#SegmentXYForecast.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.SegmentXYForecast.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Forecast sliding window segmentation for time series or sequence datasets.
Note this transformation changes the number of samples in the data.
Currently sample weights always returned as None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_series, …]</span></dt>
<dd><p class="first last">Time series data and (optionally) contextual data</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like shape [n_series]</span></dt>
<dd><p class="first last">target vector</p>
</dd>
<dt><strong>sample_weight</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like shape [n_series], default = None</span></dt>
<dd><p class="first last">sample weights</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_segments, ]</span></dt>
<dd><p class="first last">segmented X data</p>
</dd>
<dt><strong>y_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_segments]</span></dt>
<dd><p class="first last">forecast y data</p>
</dd>
<dt><strong>sample_weight_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="seglearn.transform.PadTrunc">
<em class="property">class </em><code class="descclassname">seglearn.transform.</code><code class="descname">PadTrunc</code><span class="sig-paren">(</span><em>width=100</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#PadTrunc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.PadTrunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Transformer for using padding and truncation to enforce fixed length on all time
series in the dataset. Series’ longer than <code class="docutils literal notranslate"><span class="pre">width</span></code> are truncated to length <code class="docutils literal notranslate"><span class="pre">width</span></code>.
Series’ shorter than length <code class="docutils literal notranslate"><span class="pre">width</span></code> are padded at the end with zeros up to length <code class="docutils literal notranslate"><span class="pre">width</span></code>.</p>
<p>The same behavior is applied to the target if it is a series and passed to the transformer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>width</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int &gt;= 1</span></dt>
<dd><p class="first last">width of segments (number of samples)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#seglearn.transform.PadTrunc.fit" title="seglearn.transform.PadTrunc.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X[,&nbsp;y])</td>
<td>Fit the transform.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code>(X,&nbsp;y[,&nbsp;sample_weight])</td>
<td>Fit the data and transform (required by sklearn API)</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#seglearn.transform.PadTrunc.transform" title="seglearn.transform.PadTrunc.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X[,&nbsp;y,&nbsp;sample_weight])</td>
<td>Transforms the time series data into fixed length segments using padding and or truncation If y is a time series and passed, it will be transformed as well</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="seglearn.transform.PadTrunc.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#PadTrunc.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.PadTrunc.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the transform. Does nothing, for compatibility with sklearn API.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_series, …]</span></dt>
<dd><p class="first last">Time series data and (optionally) contextual data</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd><p class="first last">There is no need of a target in a transformer, yet the pipeline API requires this
parameter.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Returns self.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="seglearn.transform.PadTrunc.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>sample_weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#PadTrunc.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.PadTrunc.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the time series data into fixed length segments using padding and or truncation
If y is a time series and passed, it will be transformed as well</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_series, …]</span></dt>
<dd><p class="first last">Time series data and (optionally) contextual data</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like shape [n_series], default = None</span></dt>
<dd><p class="first last">target vector</p>
</dd>
<dt><strong>sample_weight</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like shape [n_series], default = None</span></dt>
<dd><p class="first last">sample weights</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_series, ]</span></dt>
<dd><p class="first last">transformed time series data</p>
</dd>
<dt><strong>y_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_series]</span></dt>
<dd><p class="first last">expanded target vector</p>
</dd>
<dt><strong>sample_weight_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="seglearn.transform.InterpLongToWide">
<em class="property">class </em><code class="descclassname">seglearn.transform.</code><code class="descname">InterpLongToWide</code><span class="sig-paren">(</span><em>sample_period</em>, <em>kind='linear'</em>, <em>categorical_target=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#InterpLongToWide"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.InterpLongToWide" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts time series in long format dataframes (where variables are sampled at different times)
to wide format data frames usable by the rest of seglearn using direct value interpolation.</p>
<p>Input data for this class must have at least 3 columns of type (time, var_type, var_value)
Additional columns are treated as additional channels of var_value
(e.g. time, var_type, var_value1, var_value2).</p>
<p>Each time series must have the same var_types and the same number of columns.</p>
<p>Default interpolation is linear, but other types can be specified.
If the target is a series, it will be resampled as well.</p>
<p>categorical_target should be set to True if the target series is a class
The transformer will then use nearest neighbor interp on the target.</p>
<p>The interpolation to a linear sampling space, and conversion to wide format dataframe results
in the removal of the time column and var_type columns in the data.</p>
<p>If start time or similar is important to the estimator, use a context variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sample_period</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numeric</span></dt>
<dd><p class="first last">desired sampling period</p>
</dd>
<dt><strong>kind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">interpolation type - valid types as per scipy.interpolate.interp1d</p>
</dd>
<dt><strong>categorical_target</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">set to True for classification problems to use nearest instead of linear interp for  the
target</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">seglearn.transform</span> <span class="k">import</span> <span class="n">InterpLongToWide</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># sample stacked input with values from 2 variables each with 2 channels</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">25</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">35</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stacked_interp</span> <span class="o">=</span> <span class="n">InterpLongToWide</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stacked_interp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">stacked_interp</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#seglearn.transform.InterpLongToWide.fit" title="seglearn.transform.InterpLongToWide.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X[,&nbsp;y])</td>
<td>Fit the transform.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code>(X,&nbsp;y[,&nbsp;sample_weight])</td>
<td>Fit the data and transform (required by sklearn API)</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#seglearn.transform.InterpLongToWide.transform" title="seglearn.transform.InterpLongToWide.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X[,&nbsp;y,&nbsp;sample_weight])</td>
<td>Transforms the time series data with linear direct value interpolation If y is a time series and passed, it will be transformed as well The time dimension is removed from the data</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="seglearn.transform.InterpLongToWide.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#InterpLongToWide.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.InterpLongToWide.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the transform. Does nothing, for compatibility with sklearn API.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_series, …]</span></dt>
<dd><p class="first last">Time series data and (optionally) contextual data</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd><p class="first last">There is no need of a target in a transformer, yet the pipeline API requires this
parameter.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Returns self.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="seglearn.transform.InterpLongToWide.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>sample_weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#InterpLongToWide.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.InterpLongToWide.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the time series data with linear direct value interpolation
If y is a time series and passed, it will be transformed as well
The time dimension is removed from the data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_series, …]</span></dt>
<dd><p class="first last">Time series data and (optionally) contextual data</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like shape [n_series], default = None</span></dt>
<dd><p class="first last">target vector</p>
</dd>
<dt><strong>sample_weight</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like shape [n_series], default = None</span></dt>
<dd><p class="first last">sample weights</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_series, ]</span></dt>
<dd><p class="first last">transformed time series data</p>
</dd>
<dt><strong>y_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_series]</span></dt>
<dd><p class="first last">expanded target vector</p>
</dd>
<dt><strong>sample_weight_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like or None</span></dt>
<dd><p class="first last">None is returned if target is changed. Otherwise it is returned unchanged.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="seglearn.transform.Interp">
<em class="property">class </em><code class="descclassname">seglearn.transform.</code><code class="descname">Interp</code><span class="sig-paren">(</span><em>sample_period</em>, <em>kind='linear'</em>, <em>categorical_target=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#Interp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.Interp" title="Permalink to this definition">¶</a></dt>
<dd><p>Transformer for resampling time series data to a fixed period over closed interval
(direct value interpolation).
Default interpolation is linear, but other types can be specified.
If the target is a series, it will be resampled as well.</p>
<p>categorical_target should be set to True if the target series is a class
The transformer will then use nearest neighbor interp on the target.</p>
<p>This transformer assumes the time dimension is column 0, i.e. X[0][:,0]
Note the time dimension is removed, since this becomes a linear sequence.
If start time or similar is important to the estimator, use a context variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sample_period</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numeric</span></dt>
<dd><p class="first last">desired sampling period</p>
</dd>
<dt><strong>kind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">interpolation type - valid types as per scipy.interpolate.interp1d</p>
</dd>
<dt><strong>categorical_target</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">set to True for classification problems to use nearest instead of linear interp for  the
target</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#seglearn.transform.Interp.fit" title="seglearn.transform.Interp.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X[,&nbsp;y])</td>
<td>Fit the transform.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code>(X,&nbsp;y[,&nbsp;sample_weight])</td>
<td>Fit the data and transform (required by sklearn API)</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#seglearn.transform.Interp.transform" title="seglearn.transform.Interp.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X[,&nbsp;y,&nbsp;sample_weight])</td>
<td>Transforms the time series data with linear direct value interpolation If y is a time series and passed, it will be transformed as well The time dimension is removed from the data</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="seglearn.transform.Interp.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#Interp.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.Interp.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the transform. Does nothing, for compatibility with sklearn API.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_series, …]</span></dt>
<dd><p class="first last">Time series data and (optionally) contextual data</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd><p class="first last">There is no need of a target in a transformer, yet the pipeline API requires this
parameter.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Returns self.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="seglearn.transform.Interp.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>sample_weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#Interp.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.Interp.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the time series data with linear direct value interpolation
If y is a time series and passed, it will be transformed as well
The time dimension is removed from the data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_series, …]</span></dt>
<dd><p class="first last">Time series data and (optionally) contextual data</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like shape [n_series], default = None</span></dt>
<dd><p class="first last">target vector</p>
</dd>
<dt><strong>sample_weight</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like shape [n_series], default = None</span></dt>
<dd><p class="first last">sample weights</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_series, ]</span></dt>
<dd><p class="first last">transformed time series data</p>
</dd>
<dt><strong>y_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_series]</span></dt>
<dd><p class="first last">expanded target vector</p>
</dd>
<dt><strong>sample_weight_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like or None</span></dt>
<dd><p class="first last">None is returned if target is changed. Otherwise it is returned unchanged.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="seglearn.transform.FeatureRep">
<em class="property">class </em><code class="descclassname">seglearn.transform.</code><code class="descname">FeatureRep</code><span class="sig-paren">(</span><em>features='default'</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#FeatureRep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.FeatureRep" title="Permalink to this definition">¶</a></dt>
<dd><p>A transformer for calculating a feature representation from segmented time series data.</p>
<p>This transformer calculates features from the segmented time series’, by computing the same
feature set for each segment from each time series in the data set.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">features</span></code> computed are a parameter of this transformer, defined by a dict of functions.
The seglearn package includes some useful features, but this basic feature set can be easily
extended.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>features</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd><p class="first">Dictionary of functions for calculating features from a segmented time series.
Each function in the dictionary is specified to compute features from a
multivariate segmented time series along axis 1 (the segment) eg:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="k">return</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="go">X : array-like shape [n_samples, segment_width, n_variables]</span>
<span class="go">F : array-like [n_samples, n_features]</span>
<span class="go">The number of features returned (n_features) must be &gt;= 1</span>
</pre></div>
</div>
<p class="last">If features is not specified, a default feature dictionary will be used (see base_features).
See <code class="docutils literal notranslate"><span class="pre">feature_functions</span></code> for example implementations.</p>
</dd>
<dt><strong>verbose: boolean, optional (default false)</strong></dt>
<dd><p class="first last">Controls the verbosity of output messages</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">seglearn.transform</span> <span class="k">import</span> <span class="n">FeatureRep</span><span class="p">,</span> <span class="n">SegmentX</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">seglearn.pipe</span> <span class="k">import</span> <span class="n">Pype</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">seglearn.feature_functions</span> <span class="k">import</span> <span class="n">mean</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">skew</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">seglearn.datasets</span> <span class="k">import</span> <span class="n">load_watch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="k">import</span> <span class="n">RandomForestClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">load_watch</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">mean</span><span class="p">,</span> <span class="s1">&#39;var&#39;</span><span class="p">:</span> <span class="n">var</span><span class="p">,</span> <span class="s1">&#39;std&#39;</span><span class="p">:</span> <span class="n">std</span><span class="p">,</span> <span class="s1">&#39;skew&#39;</span><span class="p">:</span> <span class="n">skew</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">Pype</span><span class="p">([(</span><span class="s1">&#39;seg&#39;</span><span class="p">,</span> <span class="n">SegmentX</span><span class="p">()),</span>
<span class="gp">&gt;&gt;&gt; </span>            <span class="p">(</span><span class="s1">&#39;ftr&#39;</span><span class="p">,</span> <span class="n">FeatureRep</span><span class="p">(</span><span class="n">features</span> <span class="o">=</span> <span class="n">fts</span><span class="p">)),</span>
<span class="gp">&gt;&gt;&gt; </span>            <span class="p">(</span><span class="s1">&#39;rf&#39;</span><span class="p">,</span><span class="n">RandomForestClassifier</span><span class="p">())])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">clf</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>f_labels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of string feature labels (in order) corresponding to the computed features</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#seglearn.transform.FeatureRep.fit" title="seglearn.transform.FeatureRep.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X[,&nbsp;y])</td>
<td>Fit the transform</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code>(X[,&nbsp;y])</td>
<td>Fit to data, then transform it.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#seglearn.transform.FeatureRep.transform" title="seglearn.transform.FeatureRep.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X)</td>
<td>Transform the segmented time series data into feature data.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="seglearn.transform.FeatureRep.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#FeatureRep.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.FeatureRep.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the transform</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_series, …]</span></dt>
<dd><p class="first last">Segmented time series data and (optionally) contextual data</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd><p class="first last">There is no need of a target in a transformer, yet the pipeline API requires this
parameter.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Returns self.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="seglearn.transform.FeatureRep.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#FeatureRep.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.FeatureRep.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the segmented time series data into feature data.
If contextual data is included in X, it is returned with the feature data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_series, …]</span></dt>
<dd><p class="first last">Segmented time series data and (optionally) contextual data</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array shape [n_series, …]</span></dt>
<dd><p class="first last">Feature representation of segmented time series data and contextual data</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="seglearn.transform.FeatureRepMix">
<em class="property">class </em><code class="descclassname">seglearn.transform.</code><code class="descname">FeatureRepMix</code><span class="sig-paren">(</span><em>transformers</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#FeatureRepMix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.FeatureRepMix" title="Permalink to this definition">¶</a></dt>
<dd><p>A transformer for calculating a feature representation from segmented time series data.</p>
<p>This transformer calculates features from the segmented time series’, by applying the supplied
list of FeatureRep transformers on the specified columns of data. Non-specified columns are
dropped.</p>
<p>The segmented time series data is expected to enter this transform in the form of
num_samples x segment_size x num_features and to leave this transform in the form of
num_samples x num_features. The term columns refers to the last dimension of both
representations.</p>
<dl class="docutils">
<dt>Note: This code is partially taken (_validate and _transformers functions with docstring) from</dt>
<dd>the scikit-learn ColumnTransformer made available under the 3-Clause BSD license.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>transformers</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of (name, transformer, columns) to be applied on the segmented time series</span></dt>
<dd><dl class="first last docutils">
<dt>name <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">unique string which is used to prefix the f_labels of the FeatureRep below</p>
</dd>
<dt>transformer <span class="classifier-delimiter">:</span> <span class="classifier">FeatureRep transform</span></dt>
<dd><p class="first last">to be applied on the columns specified below</p>
</dd>
<dt>columns <span class="classifier-delimiter">:</span> <span class="classifier">integer, slice or boolean mask</span></dt>
<dd><p class="first last">to specify the columns to be transformed</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">seglearn.transform</span> <span class="k">import</span> <span class="n">FeatureRepMix</span><span class="p">,</span> <span class="n">FeatureRep</span><span class="p">,</span> <span class="n">SegmentX</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">seglearn.pipe</span> <span class="k">import</span> <span class="n">Pype</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">seglearn.feature_functions</span> <span class="k">import</span> <span class="n">mean</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">skew</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">seglearn.datasets</span> <span class="k">import</span> <span class="n">load_watch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="k">import</span> <span class="n">RandomForestClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">load_watch</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">Pype</span><span class="p">([(</span><span class="s1">&#39;seg&#39;</span><span class="p">,</span> <span class="n">SegmentX</span><span class="p">()),</span>
<span class="gp">&gt;&gt;&gt; </span>            <span class="p">(</span><span class="s1">&#39;union&#39;</span><span class="p">,</span> <span class="n">FeatureRepMix</span><span class="p">([</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="p">(</span><span class="s1">&#39;ftr_a&#39;</span><span class="p">,</span> <span class="n">FeatureRep</span><span class="p">(</span><span class="n">features</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">mean</span><span class="p">}),</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="p">(</span><span class="s1">&#39;ftr_b&#39;</span><span class="p">,</span> <span class="n">FeatureRep</span><span class="p">(</span><span class="n">features</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;var&#39;</span><span class="p">:</span> <span class="n">var</span><span class="p">}),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="p">(</span><span class="s1">&#39;ftr_c&#39;</span><span class="p">,</span> <span class="n">FeatureRep</span><span class="p">(</span><span class="n">features</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;std&#39;</span><span class="p">:</span> <span class="n">std</span><span class="p">}),</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">)),</span>
<span class="gp">&gt;&gt;&gt; </span>                <span class="p">(</span><span class="s1">&#39;ftr_d&#39;</span><span class="p">,</span> <span class="n">FeatureRep</span><span class="p">(</span><span class="n">features</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;skew&#39;</span><span class="p">:</span> <span class="n">skew</span><span class="p">}),</span> <span class="n">mask</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>            <span class="p">])),</span>
<span class="gp">&gt;&gt;&gt; </span>            <span class="p">(</span><span class="s1">&#39;rf&#39;</span><span class="p">,</span><span class="n">RandomForestClassifier</span><span class="p">())])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">clf</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>f_labels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of string feature labels (in order) corresponding to the computed features</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#seglearn.transform.FeatureRepMix.fit" title="seglearn.transform.FeatureRepMix.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X[,&nbsp;y])</td>
<td>Fit the transform</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code>(X[,&nbsp;y])</td>
<td>Fit to data, then transform it.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#seglearn.transform.FeatureRepMix.get_params" title="seglearn.transform.FeatureRepMix.get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code></a>([deep])</td>
<td>Get parameters for this transformer.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#seglearn.transform.FeatureRepMix.set_params" title="seglearn.transform.FeatureRepMix.set_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code></a>(**kwargs)</td>
<td>Set the parameters of this transformer.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#seglearn.transform.FeatureRepMix.transform" title="seglearn.transform.FeatureRepMix.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X)</td>
<td>Transform the segmented time series data into feature data.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="seglearn.transform.FeatureRepMix.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#FeatureRepMix.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.FeatureRepMix.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the transform</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_series, …]</span></dt>
<dd><p class="first last">Segmented time series data and (optionally) contextual data</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd><p class="first last">There is no need of a target in a transformer, yet the pipeline API requires this
parameter.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Returns self.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="seglearn.transform.FeatureRepMix.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#FeatureRepMix.get_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.FeatureRepMix.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this transformer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>deep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd><p class="first last">If True, will return the parameters for this transformer and contained transformers.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">mapping of string to any parameter names mapped to their values.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="seglearn.transform.FeatureRepMix.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#FeatureRepMix.set_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.FeatureRepMix.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this transformer.</p>
<p>Valid parameter keys can be listed with <code class="docutils literal notranslate"><span class="pre">get_params()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="seglearn.transform.FeatureRepMix.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#FeatureRepMix.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.FeatureRepMix.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the segmented time series data into feature data.
If contextual data is included in X, it is returned with the feature data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_series, …]</span></dt>
<dd><p class="first last">Segmented time series data and (optionally) contextual data</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X_new</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array shape [n_series, …]</span></dt>
<dd><p class="first last">Feature representation of segmented time series data and contextual data</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="seglearn.transform.FunctionTransformer">
<em class="property">class </em><code class="descclassname">seglearn.transform.</code><code class="descname">FunctionTransformer</code><span class="sig-paren">(</span><em>func=None</em>, <em>func_kwargs={}</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#FunctionTransformer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.FunctionTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Transformer for applying a custom function to time series data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function, optional (default=None)</span></dt>
<dd><p class="first last">the function to be applied to Xt, the time series part of X (contextual variables Xc are
passed through unaltered) - X remains unchanged if no function is supplied</p>
</dd>
<dt><strong>func_kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dictionary, optional (default={})</span></dt>
<dd><p class="first last">keyword arguments to be passed to the function call</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">returns self</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">seglearn.transform</span> <span class="k">import</span> <span class="n">FunctionTransformer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">choose_cols</span><span class="p">(</span><span class="n">Xt</span><span class="p">,</span> <span class="n">cols</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="p">[</span><span class="n">time_series</span><span class="p">[:,</span> <span class="n">cols</span><span class="p">]</span> <span class="k">for</span> <span class="n">time_series</span> <span class="ow">in</span> <span class="n">Xt</span><span class="p">]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]]),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">60</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">80</span><span class="p">],</span> <span class="p">[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">110</span><span class="p">]])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trans</span> <span class="o">=</span> <span class="n">FunctionTransformer</span><span class="p">(</span><span class="n">choose_cols</span><span class="p">,</span> <span class="n">func_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;cols&quot;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#seglearn.transform.FunctionTransformer.fit" title="seglearn.transform.FunctionTransformer.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X[,&nbsp;y])</td>
<td>Fit the transform</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_transform</span></code>(X[,&nbsp;y])</td>
<td>Fit to data, then transform it.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#seglearn.transform.FunctionTransformer.transform" title="seglearn.transform.FunctionTransformer.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(X)</td>
<td>Transforms the time series data based on the provided function.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="seglearn.transform.FunctionTransformer.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#FunctionTransformer.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.FunctionTransformer.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the transform</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_samples, …]</span></dt>
<dd><p class="first last">time series data and (optionally) contextual data</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd><p class="first last">there is no need of a target in a transformer, yet the pipeline API requires this</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">returns self</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="seglearn.transform.FunctionTransformer.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/seglearn/transform.html#FunctionTransformer.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#seglearn.transform.FunctionTransformer.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the time series data based on the provided function. Note this transformation
must not change the number of samples in the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_samples, …]</span></dt>
<dd><p class="first last">time series data and (optionally) contextual data</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Xt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape [n_samples, …]</span></dt>
<dd><p class="first last">transformed time series data</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, David Burns

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>